# -*- coding: utf-8 -*-
"""P4_smartphone.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1aIhyQt_zCc1wSD4P1TPRYeFsg6vT20sw

## **Project Part 2**
"""

from google.colab import drive
drive.mount('/content/drive')

import pandas as pd
import numpy as np
import seaborn as sb
import matplotlib.pyplot as plt
from matplotlib import pyplot
import warnings
from statsmodels.tsa.arima_model import ARIMA 
from sklearn.metrics import mean_squared_error
from pandas import DataFrame
from pandas.core.common import SettingWithCopyWarning
from sklearn.model_selection import train_test_split, cross_val_score, KFold
from sklearn.neighbors import NearestCentroid, KNeighborsClassifier
from sklearn.feature_selection import SequentialFeatureSelector
from sklearn.metrics import accuracy_score, confusion_matrix, ConfusionMatrixDisplay, plot_confusion_matrix, classification_report
from sklearn.preprocessing import MinMaxScaler, StandardScaler
from sklearn.preprocessing import LabelEncoder
from sklearn.metrics import f1_score, precision_recall_fscore_support, precision_score, recall_score
from sklearn import metrics
import itertools
from pandas.plotting import parallel_coordinates

warnings.simplefilter(action="ignore", category=SettingWithCopyWarning)

df_smartphone = pd.read_csv('/content/drive/MyDrive/COMP3602 - Project/Copy of mobile_data.csv')

df_smartphone

df_smartphone.drop('Unnamed: 0', inplace=True, axis=1)

df_smartphone[['Brand and model', 'color and gb']] = df_smartphone['Mobile Name'].str.split('(', n=1, expand=True)

df_smartphone[['Brand', 'Model']] = df_smartphone['Brand and model'].str.split(' ', n=1, expand=True)

df_smartphone

df_smartphone.drop('Brand and model', inplace=True, axis=1)

df_smartphone[['Color', 'uneeded gb']] = df_smartphone['color and gb'].str.split(',', n=1, expand=True)

df_smartphone

df_smartphone.drop('color and gb', inplace=True, axis=1)

df_smartphone.drop('uneeded gb', inplace=True, axis=1)

df_smartphone

df_smartphone.info()

df_smartphone['Mobile Name'].describe()

df_smartphone['Battery'].value_counts()

"""Add column for released date"""

df_phoneDate = pd.read_csv('/content/drive/MyDrive/COMP3602/project/Phone_to_Smartphone.csv')

df_phoneDate

releasedDate = np.empty((len(df_smartphone),1,))
releasedDate[:] = np.nan
releasedDate = releasedDate.tolist()

smartphoneName = df_smartphone['Mobile Name'].tolist()
phoneDateName = df_phoneDate['Name'].tolist()
phoneReleased = df_phoneDate['released_at'].tolist()

for i in range(len(smartphoneName)):
  for j in range(len(phoneDateName)):
    if smartphoneName[i].lower().__contains__(phoneDateName[j].lower()):
      releasedDate[i] = phoneReleased[j]

len(releasedDate)

df_smartphone['released Date'] = releasedDate

df_smartphone

# delete rows that miss released and cancelled date 
df_smartphone = df_smartphone[df_smartphone["released Date"].str.contains("Cancelled") == False]
df_smartphone.dropna(axis=0, inplace = True)

len(df_smartphone)

df_smartphone['released Date'].str.count('Cancelled').sum()

month_labels = {'January': '1', 'February': '2', 'March': '3', 'April': '4', 'May': '5', 'June': '6', 'July': '7', 'August': '8', 
                'September': '9', 'October': '10', 'November': '11', 'December': '12', 'Q1' : '3', 'Q2' : '6', 'Q3' : '9', 'Q4' : '12'}

df_smartphone['released Date'] = df_smartphone['released Date'].str.replace('Released', '')
df_smartphone['released Date'] = df_smartphone['released Date'].str.replace(',', '')
df_smartphone.replace({"released Date": month_labels}, inplace=True)
df_smartphone['released Date'].replace(month_labels, inplace=True, regex=True)

df_smartphone

# change type of released Date to date format
#df_smartphone['released Date'] = df_smartphone['released Date'].str.split(',').str[0]
df_smartphone['released Date'] = pd.to_datetime(df_smartphone['released Date'])

df_smartphone

df_smartphone['Color'] = df_smartphone['Color'].str.replace('(', '')
df_smartphone['Color'] = df_smartphone['Color'].str.replace(')', '')

df_smartphone['Color'].unique()

df_smartphone.drop('Mobile Name', inplace=True, axis=1)

"""Working with Price column"""

# delete ₹ from price
df_smartphone['Price'] = df_smartphone['Price'].str.replace('₹', '')
df_smartphone['Price'] = df_smartphone['Price'].str.replace(',', '')
# convert price column to numric
df_smartphone['Price'] = pd.to_numeric(df_smartphone['Price'])
# convert currency from INR to OMR
df_smartphone['Price\OMR'] = df_smartphone["Price"] * 0.0047
df_smartphone.drop('Price', inplace=True, axis=1)

"""Working with rating column """

df_smartphone['Rating'].unique()

# replace none values with 0
df_smartphone['Rating'] = df_smartphone['Rating'].str.replace('None', '0')
# convert Rating column to numric
df_smartphone['Rating*'] = pd.to_numeric(df_smartphone['Rating'])
df_smartphone.drop('Rating', inplace=True, axis=1)

df_smartphone

"""working with ram column"""

# split ram column into ram, rom and external storage support 
df_smartphone['RAM'] = df_smartphone['RAM'].str.replace('GB', '')
df_smartphone['RAM'] = df_smartphone['RAM'].str.replace('Expandable' , '')
df_smartphone['RAM'] = df_smartphone['RAM'].str.replace('Upto', '')
df_smartphone['RAM'] = df_smartphone['RAM'].str.replace('RAM', '')
df_smartphone['RAM'] = df_smartphone['RAM'].str.replace('ROM', '')
df_smartphone['RAM'] = df_smartphone['RAM'].str.replace('TB', '000')
df_smartphone['RAM'] = df_smartphone['RAM'].str.replace('None', '0')
df_smartphone['RAM'] = df_smartphone['RAM'].str.replace(' ', '')

df_smartphone['RAM'][df_smartphone['RAM'].str.contains('MB')] =  '.' + df_smartphone['RAM'][df_smartphone['RAM'].str.contains('MB')]
df_smartphone['RAM'] = df_smartphone['RAM'].str.replace('MB', '')
df_smartphone[['RAM*', 'ROM', 'ESS Upto']] = df_smartphone['RAM'].str.split('|', expand=True)
df_smartphone.drop('RAM', inplace=True, axis=1)

#convert RAM*, ROM and ESS Upto columns to numric
df_smartphone['RAM*'] = pd.to_numeric(df_smartphone['RAM*'])
df_smartphone['ROM'] = pd.to_numeric(df_smartphone['ROM'])
df_smartphone['ESS Upto'] = pd.to_numeric(df_smartphone['ESS Upto'])
df_smartphone['ESS Upto'].fillna(0, inplace = True)

df_smartphone['RAM*'].unique()

df_smartphone

"""Working with display column"""

# split display column to display size and display type
df_smartphone['Display'] = df_smartphone['Display'].str.replace('Display', '')
df_smartphone['Display'] = df_smartphone['Display'].str.replace('(?i)inch', '', regex=True)
df_smartphone['Display'] = df_smartphone['Display'].str.replace('es', '')
df_smartphone['Display'] = df_smartphone['Display'].str.split('(').str[1]
df_smartphone[['Display Size\inch', 'Display Type']] = df_smartphone['Display'].str.split(')', n=1, expand=True)
df_smartphone.drop('Display', inplace=True, axis=1)

# delete rows that contains cm
df_smartphone = df_smartphone[df_smartphone['Display Size\inch'].str.contains("cm") == False]
# change type of display size to numric
df_smartphone['Display Size\inch'] = pd.to_numeric(df_smartphone['Display Size\inch'])

df_smartphone

"""Working with camera column"""

# delete string in camera 

df_smartphone['Camera'] = df_smartphone['Camera'].str.replace('(?i)rear', '', regex=True)
df_smartphone['Camera'] = df_smartphone['Camera'].str.replace('(?i)front', '', regex=True)
df_smartphone['Camera'] = df_smartphone['Camera'].str.replace('(?i)camera', '', regex=True)
df_smartphone['Camera'] = df_smartphone['Camera'].str.replace('(?i)mp', '', regex=True)
df_smartphone['Camera'] = df_smartphone['Camera'].str.replace('(?i)dual', '', regex=True)
df_smartphone['Camera'] = df_smartphone['Camera'].str.replace('\(.*?\)', '', regex=True)

# split Camera column into rear and front camera
df_smartphone[['Rear Cam', 'Front Cam']] = df_smartphone['Camera'].str.split('|', n=1, expand=True)
# split Front Camera into 2 columns
df_smartphone[['Front Prime Cam', 'Front Wide Cam']] = df_smartphone['Front Cam'].str.split('+', n=1, expand=True)
# split Rear Camera into 3 columns
df_smartphone[['Rear Prime Cam', 'Rear Wide Cam', 'Rear Micro Cam']] = df_smartphone['Rear Cam'].str.split('+', n=2, expand=True)

df_smartphone

df_smartphone['Front Wide Cam'].unique()

df_smartphone['Front Prime Cam'].unique()

df_smartphone['Front Prime Cam'] = df_smartphone['Front Prime Cam'].fillna('0')
df_smartphone['Front Wide Cam'] = df_smartphone['Front Wide Cam'].fillna('0')
df_smartphone['Rear Wide Cam'] = df_smartphone['Rear Wide Cam'].fillna('0')
df_smartphone['Rear Micro Cam'] = df_smartphone['Rear Micro Cam'].fillna('0')
df_smartphone.drop('Camera', inplace=True, axis=1)
df_smartphone.drop('Front Cam', inplace=True, axis=1)
df_smartphone.drop('Rear Cam', inplace=True, axis=1)

# keep only numbers in cams
df_smartphone['Front Wide Cam'] = df_smartphone['Front Wide Cam'].str.extract('(\d+)')
df_smartphone['Rear Prime Cam'] = df_smartphone['Rear Prime Cam'].str.extract('(\d+)')
df_smartphone['Rear Wide Cam'] = df_smartphone['Rear Wide Cam'].str.extract('(\d+)')
df_smartphone['Rear Micro Cam'] = df_smartphone['Rear Micro Cam'].str.extract('(\d+)')

df_smartphone['Front Prime Cam'].value_counts()

# change type of (front, Rear), prime, wide and micro cam to numric
df_smartphone['Front Prime Cam'] = pd.to_numeric(df_smartphone['Front Prime Cam'])
df_smartphone['Front Wide Cam'] = pd.to_numeric(df_smartphone['Front Wide Cam'])
df_smartphone['Rear Prime Cam'] = pd.to_numeric(df_smartphone['Rear Prime Cam'])
df_smartphone['Rear Wide Cam'] = pd.to_numeric(df_smartphone['Rear Wide Cam'])
df_smartphone['Rear Micro Cam'] = pd.to_numeric(df_smartphone['Rear Micro Cam'])

df_smartphone

"""Working with Battery column"""

# remove unnecessary strings
df_smartphone['Battery'] = df_smartphone['Battery'].str.replace(' (?i)mah ', '|', regex=True)
# split battery column into battery capacity and type
df_smartphone[['Battery Capacity', 'Battery Type']] = df_smartphone['Battery'].str.split('|', n=1, expand=True)
df_smartphone.drop('Battery', inplace=True, axis=1)

df_smartphone

df_smartphone['Battery Type'].unique()

df_smartphone['Battery Type'][df_smartphone['Battery Type'] == "Battery"] =  'not-specified'
# delete rows that not specified battery capacity
df_smartphone = df_smartphone[df_smartphone['Battery Capacity'].str.contains("None") == False]
# convert battery capacity type to numeric
df_smartphone['Battery Capacity'] = pd.to_numeric(df_smartphone['Battery Capacity'] )

df_smartphone

"""Working with processor column"""

# delete processor word from column
df_smartphone['Processor*'] = df_smartphone['Processor'].str.replace('(?i)Processor', '', regex=True)
df_smartphone.drop('Processor', inplace=True, axis=1)

df_smartphone

# rearrange data
df_smartphone.reset_index(drop=True, inplace = True)
df_smartphone

"""Summarize categorical variable"""

df_smartphone['Brand'].unique()

df_smartphone['Battery Type'].unique()

#df_smartphone.plot(kind = 'hist',x = 'Brand', y = 'Rating*')
df_smartphone['Brand'].value_counts().plot(kind = 'pie')

df_smartphone['Battery Type'].value_counts().plot(kind='bar', xlabel='Battery Type', ylabel='count', rot=90)

df_smartphone['Display Type'].value_counts().plot(kind='bar', xlabel='Display Type', ylabel='count', rot=90)

#group the data on brand and Processor value.
df_smartBrand = df_smartphone.groupby(['Brand', 'Processor*'])

df_smartBrand.first()

"""Describe the statistics for numerical features"""

df_smartphone.info()

df_smartphone.describe()

# range of Price\OMR column
df_smartphone['Price\OMR'].max() - df_smartphone['Price\OMR'].min()

# range of Rating column
df_smartphone['Rating*'].max() - df_smartphone['Rating*'].min()

# range of RAM* column
df_smartphone['RAM*'].max() - df_smartphone['RAM*'].min()

# range of ROM* column
df_smartphone['ROM'].max() - df_smartphone['ROM'].min()

# range of ESS Upto column
df_smartphone['ESS Upto'].max() - df_smartphone['ESS Upto'].min()

# range of Battery Capacity column
df_smartphone['Battery Capacity'].max() - df_smartphone['Battery Capacity'].min()

df_smartphone.plot(kind = 'scatter',x = 'Price\OMR', y = 'Rating*', figsize=(15,5))

df_smartphone.plot(kind = 'line',x = 'released Date', y = 'Price\OMR', style="k-", label="released Date", figsize=(20,5))

"""correlations between 2 variables"""

# Correlation between price and ram
price_rating_corr =df_smartphone['Price\OMR'].corr(df_smartphone['RAM*'])
price_rating_corr

"""the dataset is Tidy(Long)"""

df_smartPhone_wide = pd.pivot_table(df_smartphone, index = 'Brand', columns= 'released Date', values = 'Price\OMR')
df_smartPhone_wide.columns.name = ""
df_smartPhone_wide.reset_index(inplace = True)
df_smartPhone_wide

df_smartPhone_long = pd.melt(df_smartPhone_wide, id_vars = ['Brand'], var_name='released Date', value_name='Price\OMR')
df_smartPhone_long.sort_values(by=['Brand'], inplace=True)
df_smartPhone_long

"""application of a pivot table with an aggregation function"""

df_smartPhone_priceAvg = pd.pivot_table(df_smartphone, values = 'Price\OMR', index = 'Brand', aggfunc = ['mean', 'count'])
df_smartPhone_priceAvg

"""#Project Part 3"""

df_smartBrand.head()

df_smartBrand['released Date'].dtype

"""2. Describe the trends (increase, decrease, plateau, … etc.) for at least 2 variables
with the help of a plot


"""

# between price and released date
df_smartphone.plot(x = 'released Date', y = 'Price\OMR', style="k-", label="released Date", figsize=(50,10))

"""3. Describe a relationship between variables within your time series dataset. You can describe a relationship between a variable current values and its previous values or relationship between 2 variables. Use plots if possible to explain your result."""

# between Battery Capacity and released date
df_smartphone.plot(x = 'released Date', y = 'Battery Capacity', style="k-", label="released Date", figsize=(50,10))

"""4. Extract trends from your time series and describe if your time series data contain
stationary/non-stationary and/or seasonality/cyclicity. Again use plots to
illustrate your point
"""

ax = df_smartphone.plot(x='released Date', y='Price\OMR', figsize=(12,6))
xcoords = ['2010-01-01', '2011-01-01', '2012-01-01', '2013-01-01', '2014-01-01' ,'2015-01-01', '2016-01-01','2017-01-01', '2018-01-01', '2019-01-01', '2020-01-01',
          '2021-01-01']
for xc in xcoords:
    plt.axvline(x=xc, color='black', linestyle='--')

df_smartphone.info()

values = df_smartphone.iloc[:,4].values
values

# getting the count to split the dataset into 3
parts = int(len(values)/3)

# splitting the data into three parts
part_1, part_2, part_3 = values[0:parts], values[parts:(parts*2)], values[(parts*2):(parts*3)]

# calculating the mean of the separated three parts of data individually.
mean_1, mean_2, mean_3 = part_1.mean(), part_2.mean(), part_3.mean()

# calculating the variance of the separated three parts of data individually.
var_1, var_2, var_3 = part_1.var(), part_2.var(), part_3.var()

# printing the mean of three groups
print('mean1=%f, mean2=%f, mean2=%f' % (mean_1, mean_2, mean_3))

# printing the variance of three groups
print('variance1=%f, variance2=%f, variance2=%f' % (var_1, var_2, var_3))

"""5. Pick a variable from your time series data and implement ARIMA model for
stationary data or other appropriate model for non-stationary data. Use the
model to plot a forecast of your selected variable. [NOTE: You can stationarize
your data and then apply ARIMA].
"""

model = ARIMA(df_smartphone['Price\OMR'], order=(5,1,0)) 
model_fit = model.fit(disp=0) 
print(model_fit.summary()) 
# plot residual errors 
residuals = DataFrame(model_fit.resid) 
residuals.plot() 
pyplot.show() 
residuals.plot(kind='kde') 
pyplot.show() 
print(residuals.describe())

X = df_smartphone['Price\OMR'].values 
size = int(len(X) * 0.66) 
#use two thirds of the data to train
train, test = X[0:size], X[size:len(X)] 
history = [x for x in train] 
predictions = list() 
for t in range(len(test)):     
  model = ARIMA(history, order=(5,1,0))     
  model_fit = model.fit(disp=0)     
  output = model_fit.forecast()     
  yhat = output[0]     
  predictions.append(yhat)     
  obs = test[t]     
  history.append(obs)     
  print('predicted=%f, expected=%f' % (yhat, obs))

#compute the error using MSE metric 
error = mean_squared_error(test, predictions)
print('Test MSE: %.3f' % error)

pyplot.plot(test)
pyplot.plot(predictions, color='red')
pyplot.show()

"""6. Include any temporal analysis in your report that serves to answer a chosen
question relevant to your selected dataset. An example question, for instance,
could be do students in general perform better in the first semester than later
semesters in SQU?
"""

df_smartphone.plot(x = 'released Date', y = 'Display Size\inch', style="k-", label="released Date", figsize=(50,10))

"""#Project Part 4

1.Define a categorical outcome for classification or prediction from your data. Describe this
outcome and what is your plan for utilizing supervised learning to predict this outcome
"""

df_smartphone.dtypes

df = df_smartphone.dropna()
df

df.isna().sum()

dfc = df.copy()
# convert column 'Brand' from object to category
dfc['Brand'] = dfc['Brand'].astype('category')
# encode the categories of Brand to numerical values
dfc['Brand'] = dfc['Brand'].cat.codes

# same for other objet columns
dfc['Model'] = dfc['Model'].astype('category')
dfc['Model'] = dfc['Model'].cat.codes

dfc['released Date'] = dfc['released Date'].astype('category')
dfc['released Date'] = dfc['released Date'].cat.codes
#
dfc['Color'] = dfc['Color'].astype('category')
dfc['Color'] = dfc['Color'].cat.codes

dfc['Display Type'] = dfc['Display Type'].astype('category')
dfc['Display Type'] = dfc['Display Type'].cat.codes

dfc['Battery Type'] = dfc['Battery Type'].astype('category')
dfc['Battery Type'] = dfc['Battery Type'].cat.codes

dfc['Processor*'] = dfc['Processor*'].astype('category')
dfc['Processor*'] = dfc['Processor*'].cat.codes

dfc

"""2.Prepare the dataset in the form of X and y (where X are all the relevant input features and y
is the outcome). Note that you may need to apply some transformation and pre-processing to
prepare the data for the task. Describe all of your steps.

"""

dfc['Price\OMR'].min()

dfc['Price\OMR'].max()

# create price range class from Price\OMR to use it in classification lebel
# 0 price(0,65) ==> low class
# 1 price(66,185) ==> Medium class
# 3 price(186,355) ==> flagship class
# 4 price(356,inf) ==> high class
price_range = []
for val in dfc['Price\OMR']:
    if val < 66 :    price_range.append(0)
    elif val < 186 :   price_range.append(1)
    elif val < 356 :  price_range.append(3)
    else:   price_range.append(4)

dfc['price_range'] = price_range

dfc.drop('Price\OMR', axis =1, inplace=True)

# take all values of df2 from 1st to before-lasst colum in the matrix X
X = dfc.iloc[:,:-1].values
X

# take the las column (targets) in the vector y
y = dfc.iloc[:,-1].values
y

# create the scaler object and fit it to the feature
mm_scaler = MinMaxScaler()
mm_scaler.fit(X)
# transform the features
X_scaled = mm_scaler.transform(X)
X_scaled

# for example, the first feature (before scaling)
print('Min = %2.2f, Max %2.2f, std = %2.2f'%(X[:,0].min(), X[:,0].max(), X[:,0].std() ))
# after scaling
print('Min = %2.2f, Max = %2.2f, std = %2.2f'%(X_scaled[:,0].min(), X_scaled[:,0].max(), X_scaled[:,0].std() ))

"""3.Explore the outcome variable y using e.g. countplot or any other similar plot. 

What is the majority category class that you have? class 0

Do you have skewed or imbalanced data? skewed data

How do you intend to handle any imbalance?
"""

sb.countplot(data= dfc, x = y)

"""4.Divide your dataset into training and testing and implement at least 2 classification algorithms.
Evaluate the two selected algorithms using 20%, 30% and 40% of the data (i.e. test data size). Plot
the performance and discuss the results. Define your metric clearly (accuracy, F1, precision and
recall).

### Experiment 1 (knn classification)
"""

## knn function Classification 
def Knn_classification(X_train, X_test , y_train, y_test):
    # intialize the knn model
    knn = KNeighborsClassifier(n_neighbors = 1)
    knn.fit(X_train,y_train)
    knn_y_pred = knn.predict(X_test)
    knn_accuracy = accuracy_score(y_test,knn_y_pred)
    knn_f1 = f1_score(y_test, knn_y_pred, average='macro')
    knn_pres = precision_score(knn_y_pred, y_test, average='macro')
    knn_rec =recall_score(knn_y_pred, y_test, average='macro')
    return knn_y_pred, knn_accuracy, knn_f1, knn_pres, knn_rec

"""### Expermint 2 (nearest centroid classification)"""

## nc function Classification 
def Nc_classification(X_train, X_test , y_train, y_test):
    # intialize the nc model
    nc = NearestCentroid()
    nc.fit(X_train,y_train)
    nc_y_pred = nc.predict(X_test)
    nc_accuracy = accuracy_score(y_test,nc_y_pred)
    nc_f1 = f1_score(nc_y_pred, y_test, average='macro')
    nc_pres = precision_score(nc_y_pred, y_test, average='macro')
    nc_rec =recall_score(nc_y_pred, y_test, average='macro')
    return nc_y_pred, nc_accuracy, nc_f1, nc_pres, nc_rec

"""### comparing and plot"""

def parallel_plot(data):
    plt.figure(figsize=(15,8)).gca().axes.set_ylim([0,1])
    parallel_coordinates(data, 'Algorithm' , colormap='Paired',marker='o')

accuracy = {
    'KNN':[],
    'Nc':[],
}
f1Score = {
    'KNN':[],
    'Nc':[],
}
precisionScore = {
    'KNN':[],
    'Nc':[],
}
recallScore = {
    'KNN':[],
    'Nc':[],
}

test_size = [0.2,0.3,0.4]
for i in test_size:
    X_train, X_test, y_train, y_test = train_test_split(X,y,test_size=i)
    knn_y_pred, knn_accuracy, knn_f1, knn_pres, knn_rec = Knn_classification(X_train,X_test , y_train,y_test)
    nc_y_pred, nc_accuracy, nc_f1, nc_pres, nc_rec = Nc_classification(X_train,X_test , y_train,y_test)
    accuracy['KNN'].append(knn_accuracy)
    accuracy['Nc'].append(nc_accuracy)
    f1Score['KNN'].append(knn_f1)
    f1Score['Nc'].append(nc_f1)
    precisionScore['KNN'].append(knn_pres)
    precisionScore['Nc'].append(nc_pres)
    recallScore['KNN'].append(knn_rec)
    recallScore['Nc'].append(nc_rec)

df_acc = pd.DataFrame(accuracy,index=test_size)
df_acc = df_acc.T
df_acc = df_acc.rename_axis('Algorithm').reset_index()
print("accuracy score fot different test size")
df_acc

df_f1 = pd.DataFrame(f1Score,index=test_size)
df_f1 = df_f1.T
df_f1 = df_f1.rename_axis('Algorithm').reset_index()
print("F1 score fot different test size")
df_f1

df_pres = pd.DataFrame(precisionScore,index=test_size)
df_pres = df_pres.T
df_pres = df_pres.rename_axis('Algorithm').reset_index()
print("precision score fot different test size")
df_pres

print("recall score fot different test size")
df_rec = pd.DataFrame(recallScore,index=test_size)
df_rec = df_rec.T
df_rec = df_rec.rename_axis('Algorithm').reset_index()
df_rec

print("accuracy score on the test set with different test size")
parallel_plot(df_acc)

print("F1 score on the test set with different test size")
parallel_plot(df_f1)

"""5.Repeat the previous task using 10-folds cross validation technique. Collect the performance of
each fold and plot the results for the two different algorithms using appropriate line plots.
Discuss the results. Do you see major variations in performance across the folds? Explain.
"""

k_range = range(1, 31)
k_scores = []
for k in k_range:
    knn = KNeighborsClassifier(n_neighbors=k)
    kf = KFold(n_splits=10)
    scores = cross_val_score(knn, X, y, cv=kf, scoring='accuracy')
    k_scores.append(scores.mean())

print('Mean Accuracy of each k: %.3f', k_scores)
# plot to see clearly
plt.plot(k_range, k_scores)
plt.xlabel('Value of K for KNN')
plt.ylabel('Cross-Validated Accuracy')
plt.show()

nc = NearestCentroid()
kf = KFold(n_splits=10)
scores = cross_val_score(nc, X_train, y_train, scoring='accuracy', cv=kf, n_jobs=-1)
# summarize result
print('Mean Accuracy: %.3f' % (scores.mean()))

"""6.Plot the confusion matrix for the best performing model and describe the final results."""

# Confusion matrix
cm = confusion_matrix(y_test, knn_y_pred)
print("Confusion Matrix of knn:")
disp = ConfusionMatrixDisplay(confusion_matrix=cm)
disp.plot()
plt.show()

"""7.Clustering: Define a clustering task that you can perform in your dataset. Using k-means or any
other clustering algorithm from sklearn. Implement and visualize the results of clustering.
Interpret the output and provide any final insights or conclusions you can get from these clusters
regarding your dataset
"""

from sklearn.cluster import KMeans
kmeans = KMeans(n_clusters=4).fit(dfc) 
centroids = kmeans.cluster_centers_   
print(centroids)

kmeans.labels_

#plot points and show clusters by color 
plt.figure(figsize=(15,8))
plt.scatter(dfc['Rating*'], dfc['Battery Capacity'], c= kmeans.labels_.astype(float), s=10, alpha=20) 
plt.scatter(centroids[:, 0], centroids[:, 1], c='red', s=10) 
plt.show()